# Cm编程语言

## 引用

### 1.所有者（owner）与new表达式

#### 1.1 可写所有者
类型后跟var*即为可写所有者类型，所有者指向了一个普通堆空间所存在的对象。

例子（在堆中创建一个长度为4096的i32数组）：
```cm
let owner = new(var i32[4096]);    //owner类型为int[] var*
let owner2 = new(var i32[4096]); //owner的类型为var int[] var*
```

当所有者被销毁，或者重新赋值时，则其持有物体被销毁。

```cm
{
  var owner = new(i32[4096]);
  owner = new(i32[1024]);  //4096长度的对象被销毁
} //离开owner的作用域，1024长度的对象被销毁
```

new表达式所返回的对象是一个只读的所有者。
new(var)表达式所返回的对象是一个可写所有者。

如果需要创建可变的对象，则需要使用new(var)的写法，否则创建的对象不可变。

访问所有者所拥有的对象需要使用解引用符号*，在对象前置*号即可解引用。

#### 1.2 只读所有者
类型后跟*即为只读所有者，可以从一个可写所有者转换得到。
当我们在讨论所有者时，默认在讨论只读所有者。

### 2.查看器（viewer）

#### 2.1 只读查看器
查看器可以从所有者创建，也可以从一个对象创建，它使用类型后跟&来表示，创建时，需要使用view表达式来创建查看器。
在Debug的编译方式下，编译器应该检查查看器是否有效，我们需要保持查看器所查看的对象总是有效的。

```cm
let owner = new i32[4096];  //所有者持有的对象
let array : i32[4096];  //栈上的对象
let viewer1 = view(*owner); //从所有者创建的查看器
let viewer2 = view(array);  //从栈上的对象创建的查看器
//这两个查看器的类型均为i32[]&
let x = viewer1[0]; //通过第一个查看器访问它所查看的数组的第0个元素
```

访问viewer不需要解引用。
使用view创建的查看器是只读的。
我们在讨论一般的查看器时，指的是只读查看器。

#### 2.2 可写查看器

创建可写的查看器需要使用view_var来创建可写查看器，但是这要求被查看的对象必须也是可写的。
```cm
var array : i32[4096];
let viewer = view_var(array);
viewer[0] = 100;  //通过可写查看器写入到array数组的第0个元素
```

只读的查看器可以被可写查看器赋值，但是反之不行。
