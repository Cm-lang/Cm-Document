# Cm 编程语言

## 函数语法

### 函数调用

可以使用以下方法来调用一个函数：

```bnf
<函数调用表达式> ::= <函数名> "(" <实际参数列表> ")" [ <末尾匿名函数参数> ]
<实际参数列表> ::= <实际参数> [ "," <实际参数列表> ]
```

函数调用的返回值默认是`nulltype`，因此除非是返回`void`（即无法返回）的函数，都是有返回值的，比如`f()`函数不声明返回，则可以这样写：

```cm
y = f()
```

y为`null`，其类型为`nulltype`。

对于`f: i32(i32, f32, i32)`类型的函数，我们可以使用以下方式调用：

```cm
y = f(0, 0.0, 0);
```

如果函数最后一个参数为一个匿名函数，则我们可以将 lambda 表达式拿到外边作为末尾匿名函数参数：

```swift
let y = f() {
	//函数体
}
```

如果此函数仅有一个参数，同时此参数是个函数，则我们可以省略圆括号，以上代码同下列代码等价：

```swift
let y = f {
	// 函数体
}
```

### 定义函数

我们可以使用以下语法产生一个可以被调用的函数：

```ebnf
# TODO
```

例子：

```swift
let fool = i32 { i: i32, j: i32, k: i32 ->
	// do something.
	0 // ret 0;
}
```

由于我们可以知道返回值 0 是个 i32 ，所以可以进行如下简写：

```swift
let fool = { i: i32, j: i32, k: i32 ->
	// do something.
	0
}
```

函数定义所产生的函数的类型写法参见[类型系统](../)一章。

比如我们可以在调用类型为`i32(i32, i32(i32))`的f函数时使用以下两种写法：

```cm
result = f(15, { i ->
		y = i + 100;
		y
	});
```

```cm
result = f(15) i32 { i ->
	y = i + 100;
	y
}
```

当然我们推荐后一种写法。

根据这个原理，很多流程控制语句就能通过函数表达：

```
res = unless(someBool) {
	do something;
	someValue
}
```

当参数数量为零时，可以省略参数的声明。比如`{}`也是一个合法的lambda，类型是`nulltype()`。

### 函数的返回值

```bnf
<返回值语句> ::= ( "ret" <表达式> ";" )
            | <表达式>
```

如果返回值写在函数最后一行则可以（而且必须同时）省略`ret`和分号，否则必须写上`ret`表示返回。
