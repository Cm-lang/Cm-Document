# Cm编程语言

## 引用

### 1.所有者（owner）与new表达式

类型后跟*即为所有者类型，所有者指向了一个普通堆空间所存在的对象。

例子（在堆中创建一个长度为4096的i32数组）：
```cm
let owner = new i32[4096];    //owner类型为int[]*
let owner2 = new var i32[4096]; //owner的类型为var int[]*
```

当所有者被销毁，或者重新赋值时，则其持有物体被销毁。

```cm
{
  var owner = new i32[4096];
  owner = new i32[1024];  //4096长度的对象被销毁
} //离开owner的作用域，1024长度的对象被销毁
```

new表达式所返回的对象是一个所有者。

如果需要创建可变的对象，则需要使用new var的写法，否则创建的对象不可变。

访问所有者所拥有的对象需要使用解引用符号*，在对象前置*号即可解引用。

### 2.查看器（viewer）

查看器可以从所有者创建，也可以从一个对象创建，它使用类型后跟&来表示，创建时，需要使用let&的写法来创建查看器。
在Debug的编译方式下，编译器应该检查查看器是否有效，我们需要保持查看器所查看的对象总是有效的。

```cm
let owner = new i32[4096];  //所有者持有的对象
let array : i32[4096];  //栈上的对象
let& viewer1 = *owner; //从所有者创建的查看器
let& viewer2 = array;  //从栈上的对象创建的查看器
//这两个查看器的类型均为i32[]&
let x = viewer1[0]; //通过第一个查看器访问它所查看的数组的第0个元素
```cm

访问viewer不需要解引用。
使用let&创建的查看器是只读的。

创建可写的查看器需要使用var&来创建可写查看器，但是这要求被查看的对象必须也是可写的。
```cm
var array : i32[4096];
var& viewer = array;
viewer[0] = 100;  //通过可写查看器写入到array数组的第0个元素
```cm
