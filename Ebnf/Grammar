# each '\n' will be ignored.
# `ENDL` will be replaced by '\n' when compiling.

# comments
multilineComment  
        ::= '/*' multilineComment '*/' 
            |  
            R'/\*[\W\w]*?/\*'  
        ENDL

Comment:= R'//[^\n]*'   
       ENDL

# basics
 
String  := R'[a-z]*"[\w|\W]*"' 
        ENDL

numberLiteral 
        := R'0[XxOoBb][\da-fA-F]+'  
        ENDL

Decimal := R'\d+(?:\.\d+|)(?:E\-{0,1}\d+|)' 
        ENDL

Constant:= K'null|false|true' 
        ENDL

NEWLINE := R'\n'
        ENDL


EOL     := R';' 
        ENDL

Insertable
        ::= EOL | NEWLINE | Comment | multilineComment
        ENDL

simpleName       
        := R'[a-zA-Z_][a-z0-9A-Z_]*'
        ENDL



Identifier
        ::= simpleName | '`' simpleName '`'
        ENDL

labelDeclaration
        ::= ':' Identifier
        ENDL

block   ::= '{' statements '}' 
        ENDL

body    ::=  block  | statement | Insertable* body Insertable*
        ENDL

# module related


module  ::= simpleName (',' simpleName)* 
        ENDL
moduleDeclaration 
        ::= 'module' module 
        ENDL
Import  ::= 'import' module
        ENDL

# statement 

statement 
        ::= flowControl | declaration | flowControlSign [Identifier] | expression  
        ENDL 

flowControlSign 
        := K'break|return|continue'
        ENDL

flowControl
        ::= If | While
        ENDL

If      ::= K'if' '(' expression ')' 
                body 
            [
            K'else' 
                body 
            ] 
        ENDL

While   ::=  [labelDeclaration] 
             K'while' '(' expression  ')' 
                body
        ENDL

# declaration

declaration 
        ::= structDeclaration | variableDeclaration
        ENDL

structDeclaration Throw Insertable
        ::= K'struct' Identifier '{' 
                (Insertable* variableDeclarationEntry Insertable*)* 
            '}' 
        ENDL

variableDeclarationEntry
        ::= Identifier [':' Type]
        ENDL

variableDeclarationEntryList  
        ::= variableDeclarationEntry (',' variableDeclarationEntry)* 
        ENDL

variableDeclaration
        ::= (K'let' | K'var') variableDeclarationEntry [ '=' expression ] 
        ENDL

Type    ::=  '[' TypeList '=>' Type ']' | Identifier
        ENDL

TypeList
        ::= Type (',' Type)*
        ENDL

genericParameters 
        ::= K'<' Identifier (',' Identifier)* K'>'
        ENDL

# expression

BinaryOperator := R'\/\/|\/|\|\||\||\>\>|\<\<|\>\=|\<\=|\<\-|\>|\<|\=\>|\-\-|\+\+|\*\*|\+|\-|\*|\=\=|\=|\%|\^'
                ENDL
UnaryOperator  := R'\?|\!|\&|\$|\@|\+|\-|\~' 
                ENDL

expression     
        ::= LambdaDef | BinaryOperation
        ENDL

LambdaDef Throw Insertable     
        ::= variableDeclarationEntry '->' body
            |
            '(' variableDeclarationEntryList ')' '->' body
            |
            '{' Insertable*
                [variableDeclarationEntryList '->']
                statements              # 若没有定义形式参数, 则类似kotlin的`it`或者scala的`_`
            '}' 
            | [genericParameters] [Type] LambdaDef
        ENDL

BinaryOperation 
        ::= UnaryOperation (BinaryOperator UnaryOperation)* 
        ENDL

UnaryOperation
        ::= AtomExpr | UnaryOperator UnaryOperation 
        ENDL

AtomExpr::= Atom Trailer*
        ENDL

expressionList 
        ::= expression (',' expression)*
        ENDL

## call function and get members.



Trailer ::= '(' [expressionList] ')' [LambdaDef] | '.' Identifier
        ENDL

Atom    ::= Constant | String | Identifier | numberLiteral | Decimal | '(' expression ')'
        ENDL

# extra
statements Throw Insertable
        ::= (Insertable* statement* Insertable*)*
        ENDL

